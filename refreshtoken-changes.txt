Planning Notes for Refresh Token Implementation

- User logs in, gets token + refreshtoken:
	- Unlike the token, all refreshtokens are stored in the user table.
	- Along with some info about the request (device, IP, when the refreshtoken was last used, etc.)
- User uses token to make requests
- If a request is made with an expired token:
	- User can request a new token using the refreshtoken, then use the new one.
	- If the refreshtoken is invalid, user gets 401.
- If a logged in user wants, they can take a look at their refreshtokens (not the tokens themselves, but some associated data such as device or IP) and choose to revoke the token.

Changes needed:
1. Take a look at the req object and see what data about the client is available to associate with a refreshtoken.
2. If needed, force the client to send extra info about itself on login, such as the user agent and device (reject logins without this info) for use with the above.
3. Decide on the exact info that will be stored with each refreshtoken.
4. Add a new property to the User schema, in which refreshtokens and associated info can be stored.
5. Make sure a refreshToken is generated, stored, and returned on login.
6. Make sure older refresh tokens are deleted on login (see concerns section below).
7. Create a /token endpoint that accepts a refresh token and issues a new token.
8. Make sure that every time /token is called, the last-used date for the associated refresh token is updated.
9. Test that the above system works:
	1. Log in and take note of the provided token and refresh token.
	2. Attempt to access a protected route without the token. This should return a 401.
	3. Try again with an invalid (modified) token. This should also return a 401.
	4. Attempt to access a protected route with the token before it expires. This should work.
	5. Wait for the token to expire and try again. This should return a 401.
	6. Attempt to request a new token without providing a refreshtoken. This should return a 401.
	7. Try again with an invalid (modified) refreshtoken. This should also return a 401.
	8. Attempt to request a new token using the provided refreshtoken. This should return a new token.
	9. Repeat steps 4 and 5 with the new token.
10. Create a protected /logins endpoint that returns info about existing refreshtokens.
11. Create a protected /revokelogin endpoint that revokes a specific refreshtoken.
12. Test that the above system works:
	1. Make sure you have several existing refreshtokens.
	2. Use /logins to get a list of existing refreshtokens.
	3. Pick one and use it to request a new token. This should work.
	3. Use /revokelogin to revoke the refreshtoken you picked.
	4. Try step 3 again. It should return a 401.

Progress tracking:
1. req.ip and req.headers['user-agent'] are enough.
2. No need.
3. Data in step 1.
   A unique (Mongo) ID for each refreshtoken that can be used to reference it without providing the token itself.
   The time the refreshtoken was last used (will generate on login).
4. Done.
5. Done.
6. Done.

Concerns so far:
- Sometimes, a user may manually log out (reasonable client software would destroy the refresh token then) or they may lose their refresh tokens in some other way.
  The server still stores that refresh token. Over time, this would lead to thousands of dead refresh tokens building up in the DB.
  Obviously, very old tokens should be revoked automatically. But when and how is this appropriate? Isn't the point of refresh tokens that they are forever?
  For now, I have decided that old tokens should be revoked when a new one is requested (login). Specifically:
    - All tokens that haven't been used in 30 days that came from the same IP and user agent as the latest login are revoked.
	- All tokens that haven't been used in year are revoked.
  Is this the best way? Is the IP Express recieves always accurate? What if a user has two identical user agents on the same network?
  In that case, would the IP I recieve be accurate to the individual device or the network? If it is precise, do I need the 30 day limit? Why not revoke immediately?